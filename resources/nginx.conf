http {

    # Environment variables
    env TOKEN_FILE_PATH;
    env PROXY_BUFFER_SIZE;
    env PROXY_BUFFERS;
    env PROXY_BUSY_BUFFERS_SIZE;
    env LARGE_CLIENT_HEADER_BUFFERS;
    env UPSTREAM_HOST;
    env BASE_REWRITE_PATH;
    env TOKEN_CACHE_EXPIRATION_SECONDS;
    env MAX_AUTH_RETRY_ATTEMPTS;

    lua_shared_dict cache 1m;

    init_by_lua_block {

        -- Function to read an environment variable with a default fallback
        local function getenv_with_default(env_var, default)
            local value = os.getenv(env_var)
            if not value or value == "" then
                return default
            end
            return value
        end

        -- Load configurations from environment variables
        local token_file_path = getenv_with_default("TOKEN_FILE_PATH", "/config/token")
        local token_cache_expiration = tonumber(getenv_with_default("TOKEN_CACHE_EXPIRATION_SECONDS", "3600"))

        -- Function to read the token from the file
        function read_token()
            local file = io.open(token_file_path, "r")
            if not file then
                ngx.log(ngx.ERR, "Token file not found: " .. token_file_path)
                return nil
            end

            local token = file:read("*a")
            file:close()

            if not token or token == "" then
                ngx.log(ngx.ERR, "Token file is empty or invalid")
                return nil
            end

            return token
        end

        -- Function to get the Authorization header
        function get_auth_header(clear_cache)
            clear_cache = clear_cache or false
            local auth_header = ngx.shared.cache:get("auth_header")

            if not clear_cache and auth_header then
                return auth_header
            end

            local token = read_token()
            if not token then
                ngx.log(ngx.ERR, "Failed to read the token file")
                return nil
            end

            local auth_header = "Bearer " .. token
            ngx.shared.cache:set("auth_header", auth_header, token_cache_expiration)
            ngx.log(ngx.NOTICE, "Token successfully loaded")
            return auth_header
        end

        -- Preload the token at startup
        get_auth_header()
    }

    server {

        server_name docker-mirror;

        proxy_set_header Host $UPSTREAM_HOST;
        
        proxy_buffer_size $PROXY_BUFFER_SIZE;
        proxy_buffers $PROXY_BUFFERS;
        proxy_busy_buffers_size $PROXY_BUSY_BUFFERS_SIZE;
        large_client_header_buffers $LARGE_CLIENT_HEADER_BUFFERS;

        access_by_lua_block {
            local token = get_auth_header()

            if token then
                ngx.req.set_header("Authorization", token)
            else
                ngx.log(ngx.ERR, "Failed to set the authorization token")
            end
        }

        header_filter_by_lua_block {
            local status = ngx.status
            local max_auth_retry_attempts = tonumber(os.getenv("MAX_AUTH_RETRY_ATTEMPTS")) or 1

            if status == 401 or status == 403 then
                local retry_attempt = ngx.ctx.retry_attempt or 0
                if retry_attempt < max_auth_retry_attempts then
                    ngx.log(ngx.NOTICE, "401/403 detected, retrying after refreshing the token")
                    ngx.ctx.retry_attempt = retry_attempt + 1
                    get_auth_header(true)
                    return ngx.exec(ngx.var.request_uri)
                else
                    ngx.status = ngx.HTTP_FORBIDDEN
                    ngx.log(ngx.ERR, "Maximum retry limit reached, request failed")
                    ngx.say("Access denied after multiple token refresh attempts")
                    ngx.exit(ngx.HTTP_FORBIDDEN)
                end
            end
        }

        # Main base URI
        location / {
            proxy_pass https://$UPSTREAM_HOST;
        }

        # Base URI for /v2/
        location ~ /v2/ {
            proxy_pass https://$UPSTREAM_HOST;

            # URL rewriting specific to /v2/
            set $base_rewrite_path $BASE_REWRITE_PATH;
            if ($request_uri ~* "^/v2/(.+)$") {
                rewrite ^/v2/(.+)$ $base_rewrite_path/$1 break;
            }
        }
    }
}